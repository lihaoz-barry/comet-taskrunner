# Comet Task Runner - 架构说明（中文）

## 核心概念

### 任务抽象（Task Abstraction）

系统使用**抽象基类**设计，支持两种任务类型：
1. **URLTask**: 简单的浏览器URL导航
2. **AITask**: 复杂的AI助手交互（带自动化操作）

### 关键点

**✅ 每个URL/指令执行 = 一个新的Task对象（in-memory）**

```python
# Frontend发送请求
POST /execute/url {"url": "https://example.com"}

# Backend创建NEW对象
task = task_manager.create_url_task(url)  # 新的URLTask对象

# 存储在内存字典中
task_manager.tasks[task.task_id] = task
```

## 文件结构

```
comet-taskrunner/
├── src/
│   ├── backend.py         # Flask API服务器
│   ├── frontend.py        # Tkinter GUI客户端
│   └── task_manager.py    # 任务管理核心逻辑
├── docs/
│   ├── implementation_plan.md
│   ├── task_lifecycle.md
│   ├── context.md
│   └── 架构说明（中文）.md  (本文件)
├── test_ai_task.py        # AI Task API测试脚本
├── run_app.bat            # 一键启动器
├── requirements.txt       # Python依赖
└── urls.json              # URL持久化存储
```

## 任务类型对比

### 1. URL Task (现有功能)

**功能**: 打开浏览器并导航到指定URL

**API调用**:
```python
POST /execute/url
{
    "url": "https://www.google.com"
}
```

**完成检测**:
- 浏览器进程退出
- 手动callback

**状态变化**:
```
CREATED → RUNNING → DONE
```

### 2. AI Task (新功能)

**功能**: 打开Comet软件，自动化AI助手交互

**API调用**:
```python
POST /execute/ai
{
    "instruction": "请帮我总结这个文档",
    "coordinates": {  // 可选
        "assistant_button": [100, 100],
        "task_input_box": [500, 300],
        "send_button": [800, 500]
    }
}
```

**执行流程**:
1. 启动Comet浏览器
2. **等待3秒**(让浏览器加载)
3. 点击AI助手按钮（坐标）
4. 点击任务输入框（坐标）
5. 输入指令文字
6. 点击发送按钮或按Enter

**完成检测**:
- 浏览器进程退出
- **AI截图分析（PLACEHOLDER）**
  - 每5秒检测一次
  - 使用OpenCV/AI模型识别完成状态
  - 具体逻辑未来实现

**状态变化**:
```
CREATED → RUNNING → (AI检测中...) → DONE
```

## 代码结构详解

### task_manager.py 核心设计

```python
# 抽象基类
class BaseTask(ABC):
    task_id: str           # UUID
    task_type: TaskType    # url 或 ai
    status: TaskStatus     # created/running/done/failed
    process_id: int        # Windows进程ID
    
    @abstractmethod
    def execute()         # 每个任务类型实现自己的执行逻辑
    
    @abstractmethod
    def check_completion() # 每个任务类型实现自己的完成检测

# URL任务子类
class URLTask(BaseTask):
    url: str
    
    def execute(self, comet_path):
        # 启动浏览器
        process = subprocess.Popen([comet_path, self.url])
        return process.pid
    
    def check_completion(self):
        # 简单检测：进程是否退出
        return not self.is_process_running()

# AI任务子类
class AITask(BaseTask):
    instruction: str
    coordinates: dict
    
    def execute(self, comet_path):
        # 启动浏览器
        process = subprocess.Popen([comet_path])
        
        # 后台线程执行自动化
        threading.Thread(
            target=self._automation_sequence
        ).start()
        
        return process.pid
    
    def check_completion(self):
        # 检测1：进程退出
        if not self.is_process_running():
            return True
        
        # 检测2：AI截图分析 (PLACEHOLDER)
        # return self._detect_completion_via_screenshot()
        return False
```

### TaskManager 职责

```python
class TaskManager:
    tasks: Dict[str, BaseTask]  # 所有任务存储
    
    def create_url_task(url) -> URLTask:
        """创建URL任务"""
        
    def create_ai_task(instruction) -> AITask:
        """创建AI任务"""
    
    def get_task(task_id) -> BaseTask:
        """查询任务"""
    
    def monitor_tasks():
        """
        定期检查所有RUNNING任务
        调用各自的check_completion()
        每5秒执行一次
        """
```

## 后端API端点

### 执行任务

| 端点 | 方法 | 功能 | 参数 |
|------|------|------|------|
| `/execute/url` | POST | 执行URL任务 | `{"url": "..."}` |
| `/execute/ai` | POST | 执行AI任务 | `{"instruction": "...", "coordinates": {...}}` |

### 监控任务

| 端点 | 方法 | 功能 |
|------|------|------|
| `/status/<task_id>` | GET | 获取任务状态 |
| `/callback` | POST | 手动标记完成 |
| `/jobs` | GET | 查看所有任务 |
| `/health` | GET | 健康检查 |

## PLACEHOLDER 功能说明

以下功能在代码中标记为 `# TODO` 或 `# PLACEHOLDER`，需要未来实现：

### 1. 鼠标自动化 (AITask)

**位置**: `task_manager.py` 第 400-450 行

```python
def _click_assistant_button(self):
    # TODO: 使用 pyautogui 或 win32api
    x, y = self.coordinates['assistant_button']
    # pyautogui.click(x, y)
    pass

def _type_instruction(self):
    # TODO: 使用 pyautogui
    # pyautogui.write(self.instruction, interval=0.05)
    pass
```

**需要安装**: `pip install pyautogui`

### 2. 截图捕获 (AITask)

**位置**: `task_manager.py` 第 550-570 行

```python
def _capture_window_screenshot(self):
    # TODO: 使用 win32gui + PIL
    # 1. 通过 process_id 找到 window handle (HWND)
    # 2. 捕获窗口内容
    # 3. 返回 PIL Image
    pass
```

**需要安装**: `pip install pywin32 pillow`

### 3. AI检测完成 (AITask)

**位置**: `task_manager.py` 第 520-545 行

```python
def _detect_completion_via_screenshot(self) -> bool:
    # TODO: AI模型检测
    # screenshot = self._capture_window_screenshot()
    # result = ai_model.predict(screenshot)
    # if result.label == "completed":
    #     return True
    pass
```

**可能方案**:
- **OpenCV模板匹配**: 检测特定UI元素（如"任务完成"文字）
- **AI模型**: 使用预训练的图像分类模型
- **OCR**: 使用 Tesseract 识别文字

### 4. 坐标校准

**当前**: 使用硬编码坐标

```python
coordinates = {
    'assistant_button': (100, 100),   # TODO: 测量实际位置
    'task_input_box': (500, 300),     # TODO: 测量实际位置
    'send_button': (800, 500)         # TODO: 按键盘Enter更可靠
}
```

**建议**: 创建一个坐标校准工具

```python
# 工具脚本: calibrate_coordinates.py
import pyautogui
print("Move mouse to Assistant Button and press Enter...")
input()
print(f"Recorded: {pyautogui.position()}")
```

## 后台监控线程

Backend自动启动监控线程，每5秒检查一次：

```python
# backend.py
def start_task_monitor():
    def monitor_loop():
        while True:
            task_manager.monitor_tasks()  # 调用所有任务的 check_completion()
            time.sleep(5)
    
    threading.Thread(target=monitor_loop, daemon=True).start()
```

这对AI Task特别重要，因为需要定期截图分析。

## 测试AI Task

使用提供的测试脚本：

```bash
python test_ai_task.py
```

选择 `1` 测试AI任务，会：
1. 发送AI任务到后端
2. 后端启动Comet
3. 执行自动化序列（当前是placeholder）
4. 监控任务状态
5. 显示进度

## 未来开发路线

### Phase 1: 基础自动化
- [ ] 实现鼠标点击 (`pyautogui`)
- [ ] 实现键盘输入
- [ ] 测试和调整坐标

### Phase 2: 窗口管理
- [ ] 通过process_id获取window handle
- [ ] 窗口聚焦功能
- [ ] 截图捕获

### Phase 3: AI检测
- [ ] OpenCV模板匹配
- [ ] OCR文字识别
- [ ] AI模型集成

### Phase 4: 优化
- [ ] 自适应坐标（基于窗口大小）
- [ ] 错误处理和重试
- [ ] 并行任务管理

## 常见问题

### Q: URL功能还能正常work吗？
**A**: 能！URL Task完全独立，不受AI Task影响。

### Q: 每次执行都创建新对象？
**A**: 是的。每个 `POST /execute/*` 都创建新的 Task 对象并存储在 `task_manager.tasks` 字典中。

### Q: Placeholder什么时候实现？
**A**: 按需实现。先把结构搭好，逐步填充真实逻辑。重要的是架构清晰。

### Q: 为什么不用WebSocket而用Polling？
**A**: Tkinter + Flask 架构下，WebSocket会增加很多复杂度。Polling（每1-5秒）对这个场景足够高效简单。

## 代码风格规范

所有代码遵循：
- ✅ **详细注释**：每个函数都有docstring
- ✅ **类型提示**：使用Python type hints
- ✅ **清晰命名**：变量名清楚表达意图
- ✅ **结构化**：使用注释分隔不同模块
- ✅ **Placeholder标记**：未实现功能明确标注 `# TODO` 或 `# PLACEHOLDER`

## 联系与贡献

如有问题或建议，请查看：
- `docs/task_lifecycle.md` - 技术细节
- `docs/context.md` - 快速参考
- `test_ai_task.py` - API使用示例
