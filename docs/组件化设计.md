# 组件化架构设计文档

## 核心理念：纯组件 (Pure Components)

每个Task类型现在是**独立的、可重用的组件**，遵循以下原则：

### 1. 单一职责 (Single Responsibility)
- `base_task.py`: 只定义生命周期管理
- `url_task.py`: 只实现URL导航逻辑
- `ai_task.py`: 只实现AI交互逻辑
- `task_manager.py`: 只负责存储和查询

### 2. 无框架依赖 (Framework Agnostic)
Task组件**不依赖**任何特定框架：
- ✅ 不依赖Flask
- ✅ 不依赖Tkinter
- ✅ 不依赖Django
- ✅ 只依赖标准库 + psutil

这意味着它们可以在**任何Python项目**中使用！

### 3. 明确的Input/Output契约

每个组件都有清晰的接口：

```python
# Input
task = URLTask(url="https://example.com")

# Output
process_id = task.execute(comet_path="/path/to/browser")

# Status Check
is_done = task.check_completion()  # Returns bool

# Result
result = task.complete()  # Returns TaskResult object
```

## 文件结构对比

### 之前（耦合）
```
src/
└── task_manager.py  (所有类在一个文件，3000行)
    ├── BaseTask
    ├── URLTask
    ├── AITask
    └── TaskManager
```

**问题**：
- ❌ 难以独立使用某个Task
- ❌ 测试困难
- ❌ 修改一个Task影响整个文件
- ❌ 无法在其他项目中复用

### 现在（解耦）
```
src/
├── tasks/                  (独立组件包)
│   ├── __init__.py        (公共导出接口)
│   ├── base_task.py       (基类 - 150行)
│   ├── url_task.py        (URL组件 - 180行)
│   └── ai_task.py         (AI组件 - 300行)
└── task_manager.py        (管理器 - 150行)
```

**优点**：
- ✅ 每个组件独立
- ✅ 可以单独import
- ✅ 易于测试
- ✅ 可在任何项目中复用

## 使用示例

### 示例 1：在Flask API中使用

```python
# your_flask_app.py
from flask import Flask, request, jsonify
from tasks import URLTask, AITask

app = Flask(__name__)
tasks_storage = {}  # 简单存储

@app.route('/browse', methods=['POST'])
def browse():
    """简单的URL任务API"""
    url = request.json['url']
    
    # 创建并执行Task组件
    task = URLTask(url)
    pid = task.execute(comet_path="/path/to/browser")
    task.start(pid)
    
    # 存储task
    tasks_storage[task.task_id] = task
    
    return jsonify({
        "task_id": task.task_id,
        "status": task.status.value
    })

@app.route('/status/<task_id>')
def status(task_id):
    task = tasks_storage.get(task_id)
    if not task:
        return jsonify({"error": "Not found"}), 404
    
    # 使用Task的check_completion方法
    if task.check_completion():
        task.complete()
    
    return jsonify(task.to_dict())
```

**重点**：Flask只是调用Task组件，不需要修改Task代码！

### 示例 2：在Django项目中使用

```python
# myapp/views.py
from django.http import JsonResponse
from tasks import URLTask
from .models import TaskRecord

def create_browse_task(request):
    """Django view使用Task组件"""
    url = request.POST.get('url')
    
    # 创建Task组件
    task = URLTask(url)
    pid = task.execute(comet_path=settings.BROWSER_PATH)
    task.start(pid)
    
    # 保存到Django数据库
    TaskRecord.objects.create(
        task_id=task.task_id,
        task_type='url',
        url=url,
        process_id=pid,
        status='running'
    )
    
    return JsonResponse({
        "task_id": task.task_id
    })

def check_task_status(request, task_id):
    # 从数据库加载
    record = TaskRecord.objects.get(task_id=task_id)
    
    # 重建Task对象
    task = URLTask(url=record.url)
    task.task_id = record.task_id
    task.process_id = record.process_id
    # ... 恢复其他状态
    
    # 使用Task的方法
    if task.check_completion():
        task.complete()
        record.status = 'done'
        record.save()
    
    return JsonResponse(task.to_dict())
```

### 示例 3：在CLI工具中使用

```python
# automation_cli.py
import click
import time
from tasks import AITask

@click.command()
@click.argument('instruction')
@click.option('--browser', default='/usr/bin/comet')
def ai_command(instruction, browser):
    """命令行工具使用AI Task组件"""
    print(f"Creating AI task: {instruction}")
    
    # 直接使用组件
    task = AITask(instruction)
    pid = task.execute(comet_path=browser)
    task.start(pid)
    
    print(f"Task started with PID: {pid}")
    print("Monitoring...")
    
    # 简单轮询
    while not task.check_completion():
        time.sleep(5)
        print(".", end="", flush=True)
    
    result = task.complete()
    print(f"\n✓ Task completed!")
    print(f"Duration: {result.data.get('duration_seconds')}s")

if __name__ == '__main__':
    ai_command()
```

**完全不需要Flask或Tkinter！**

### 示例 4：在Jupyter Notebook中使用

```python
# notebook.ipynb
from tasks import URLTask, AITask
import time

# Cell 1: 创建URL任务
task1 = URLTask("https://example.com")
pid = task1.execute(comet_path="/path/to/browser")
task1.start(pid)
print(f"Task ID: {task1.task_id}")

# Cell 2: 监控
while task1.status == TaskStatus.RUNNING:
    time.sleep(1)
    if task1.check_completion():
        task1.complete()
        break

# Cell 3: 查看结果
task1.to_dict()
```

### 示例 5：在FastAPI中使用

```python
# main.py
from fastapi import FastAPI
from pydantic import BaseModel
from tasks import URLTask, AITask

app = FastAPI()
tasks_db = {}

class URLRequest(BaseModel):
    url: str

@app.post("/execute/url")
async def execute_url(request: URLRequest):
    task = URLTask(url=request.url)
    pid = task.execute(comet_path="/path/to/browser")
    task.start(pid)
    
    tasks_db[task.task_id] = task
    
    return {
        "task_id": task.task_id,
        "status": task.status.value
    }

@app.get("/status/{task_id}")
async def get_status(task_id: str):
    task = tasks_db.get(task_id)
    if not task:
        return {"error": "Not found"}
    
    if task.check_completion():
        task.complete()
    
    return task.to_dict()
```

## 对比：方法1 vs 方法2

### 方法1：在同一个py文件中定义类

```python
# monolithic.py
class URLTask:
    def execute(self):
        ...

class AITask:
    def execute(self):
        ...

# 使用
from monolithic import URLTask
task = URLTask(...)
```

**限制**：
- 必须import整个文件
- 修改一个类可能影响其他类
- 测试时会加载所有代码
- 文件变得很大

### 方法2：每个组件独立文件

```python
# tasks/url_task.py
class URLTask:
    def execute(self):
        ...

# tasks/ai_task.py
class AITask:
    def execute(self):
        ...

# 使用
from tasks import URLTask  # 只导入需要的
task = URLTask(...)
```

**优点**：
- ✅ 按需导入
- ✅ 修改隔离
- ✅ 测试隔离
- ✅ 文件小而专注

## Python的最佳实践

### 1. Package结构

```python
# tasks/__init__.py
from .base_task import BaseTask, TaskStatus, TaskType
from .url_task import URLTask
from .ai_task import AITask

__all__ = ['BaseTask', 'TaskStatus', 'TaskType', 'URLTask', 'AITask']
```

这允许：
```python
# 方式1：从package导入
from tasks import URLTask, AITask

# 方式2：从specific module导入
from tasks.url_task import URLTask
from tasks.ai_task import AITask
```

### 2. 依赖注入 (Dependency Injection)

```python
# ✅ 好的设计 - 依赖通过参数传入
class URLTask:
    def execute(self, comet_path: str) -> int:
        # comet_path是参数，不是硬编码
        process = subprocess.Popen([comet_path, self.url])
        return process.pid

# ❌ 不好的设计 - 硬编码依赖
class URLTask:
    def execute(self) -> int:
        comet_path = "C:/hardcoded/path.exe"  # 硬编码！
        process = subprocess.Popen([comet_path, self.url])
        return process.pid
```

### 3. 接口契约 (Interface Contract)

使用抽象基类定义契约：

```python
from abc import ABC, abstractmethod

class BaseTask(ABC):
    @abstractmethod
    def execute(self, **kwargs) -> int:
        """必须返回int (process ID)"""
        pass
    
    @abstractmethod
    def check_completion(self) -> bool:
        """必须返回bool"""
        pass
```

这确保所有Task类型有**一致的接口**。

## Python中没有限制！

Python作为动态语言，非常适合组件化：

1. **Duck Typing**: 不需要严格的interface定义
2. **动态导入**: 可以运行时import
3. **Monkey Patching**: 可以运行时修改
4. **Mixin**: 可以组合多个功能

但**最佳实践**仍然是：
- ✅ 明确的接口（使用ABC）
- ✅ 类型提示（使用typing）
- ✅ 文档字符串（docstring）
- ✅ 单一职责（每个文件一个主要类）

## 可复用性的关键

### 1. 无副作用 (No Side Effects)

```python
# ✅ 纯函数 - 可复用
def check_completion(self) -> bool:
    return not self.is_process_running()

# ❌ 有副作用 - 难复用
def check_completion(self) -> bool:
    status = not self.is_process_running()
    self.status = "done"  # 副作用！修改了状态
    return status
```

### 2. 最小依赖 (Minimal Dependencies)

```python
# ✅ 只依赖标准库
import subprocess
import logging

# ❌ 依赖特定框架
from flask import current_app  # 只能在Flask中用
```

### 3. 配置外部化 (External Configuration)

```python
# ✅ 配置通过参数传入
task = URLTask(url="...")
task.execute(comet_path=config['browser_path'])

# ❌ 配置硬编码
task = URLTask(url="...")
task.execute()  # 内部硬编码了路径
```

## 测试优势

组件化后，测试变得简单：

```python
# test_url_task.py
import unittest
from tasks import URLTask

class TestURLTask(unittest.TestCase):
    def test_task_creation(self):
        task = URLTask("https://example.com")
        self.assertEqual(task.url, "https://example.com")
        self.assertEqual(task.status, TaskStatus.CREATED)
    
    def test_execution(self):
        task = URLTask("https://example.com")
        # Mock subprocess.Popen
        # ...
```

每个组件可以**独立测试**，不需要启动Flask或Tkinter！

## 总结

### 为什么组件化更好？

| 方面 | 单文件方式 | 组件化方式 |
|------|----------|----------|
| 复用性 | 困难 | 容易 - 直接import |
| 测试 | 困难 - 需加载所有 | 容易 - 独立测试 |
| 维护 | 困难 - 文件太大 | 容易 - 文件小而专注 |
| 扩展 | 困难 - 修改影响全部 | 容易 - 修改隔离 |
| 理解 | 困难 - 需看完整个文件 | 容易 - 每个文件清晰 |

### Python最佳实践

1. **Package结构**: `tasks/__init__.py`统一导出
2. **抽象基类**: 定义一致接口
3. **依赖注入**: 通过参数传递依赖
4. **类型提示**: 明确input/output类型
5. **文档字符串**: 详细说明用法

### 没有限制，只有最佳实践

Python非常灵活，你可以：
- ✅ 将Task组件用在任何项目
- ✅ 动态加载Task类型
- ✅ 运行时扩展Task功能
- ✅ 组合多个Task

**关键是设计清晰的接口和保持组件独立！**
